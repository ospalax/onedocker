#
# ONE Docker
#

ARG CENTOS_VERSION=8
FROM centos:${CENTOS_VERSION}
LABEL version="1.0" \
    maintainer="Petr Ospal√Ω (pospaly@opennebula.io)" \
    description="ONE Docker - Dockerized OpenNebula"

#
# BUILD ARGS
#

ARG CENTOS_VERSION
ARG OPENNEBULA_VERSION=5.12
# TODO: ARG DOCKER_VERSION=19.03

#
# PACKAGES
#

# basic packages (and remove kdump)
RUN dnf -y remove kexec-tools && dnf -y update && dnf -y install \
        epel-release \
        yum-utils \
    && dnf clean all && rm -rf /var/cache/dnf/*

# prepare opennebula repo
COPY centos/opennebula-centos.repo /etc/yum.repos.d/opennebula.repo
RUN sed -i "s/[\$][{]OPENNEBULA_VERSION[}]/${OPENNEBULA_VERSION}/" \
        /etc/yum.repos.d/opennebula.repo

# prepare docker repo
RUN yum-config-manager --add-repo \
        https://download.docker.com/linux/centos/docker-ce.repo

# opennebula packages and dependencies
RUN dnf -y install \
        mariadb \
        docker-ce-cli \
        opennebula-server \
        opennebula-ruby \
        opennebula-flow \
        opennebula-gate \
        opennebula-sunstone \
        file \
        e2fsprogs \
    && dnf clean all && rm -rf /var/cache/dnf/*

#
# CONFIGURATION
#

# each container should have unique machine-id (autogenerated on start)
RUN rm -f /etc/machine-id

# we cannot use the entrypoint (explanation below) so we will have to configure
# the onedocker deployment via systemd's oneshot service

# onedocker script which is doing the heavy-lifting
COPY onedocker-frontend.sh /
RUN chown root:root /onedocker-frontend.sh
RUN chmod 755 /onedocker-frontend.sh

# oneshot systemd service to execute onedocker script
COPY onedocker-frontend.service /etc/systemd/system/
RUN chown root:root /etc/systemd/system/onedocker-frontend.service
RUN chmod 644 /etc/systemd/system/onedocker-frontend.service

# disable autostart of opennebula services
RUN systemctl list-unit-files | \
    awk '{if (($1 ~ /^opennebula/) && ($2 != "static")) print $1;}' | \
    while read -r _oneservice ; do \
        systemctl mask "${_oneservice}" ; \
    done ;

# disable other unwanted systemd stuff
RUN systemctl mask sshd.service \
    && systemctl mask systemd-firstboot.service \
    && systemctl mask dnf-makecache.timer \
    && systemctl mask dnf-makecache.service \
    ;

# setup our entrypoint replacement - oneshot service
RUN systemctl enable onedocker-frontend.service

# cleanup the oneadmin's ssh
RUN for f in authorized_keys id_rsa id_rsa.pub ; do rm -f "/var/lib/one/.ssh/${f}" ; done

# workaround for rootless podman
#
# NOTE:
#   This avoids the need to run the container in the privilege mode but it will
#   increase its disk usage considerably - if not pruned regularly...
#RUN sed -i 's/^driver[[:space:]]*=.*/driver = "vfs"/' \
#        /etc/containers/storage.conf

#
# ENTRYPOINT
#

# systemd workarounds

# this hints the systemd that it is running inside a container
#ENV container docker

# Source: https://developers.redhat.com/blog/2016/09/13/running-systemd-in-a-non-privileged-container/
#
#   Systemd does not exit on sigterm. Systemd defines that shutdown signal as
#   SIGRTMIN+3, docker upstream should send this signal when user does a docker
#   stop.
STOPSIGNAL SIGRTMIN+3

# BEWARE: this command directive and *EMPTY* entrypoint is mandatory for podman
# to do some hidden hacks allowing systemd to mount cgroup and be able to run
# inside the container...
#
# Source: https://developers.redhat.com/blog/2019/04/24/how-to-run-systemd-in-a-container/
#
#   When Podman starts a container that is running init or systemd as its
#   initial command, Podman automatically sets up the tmpfs and Cgroups for
#   systemd to start without a problem. If you want to block the systemd
#   behavior, you have to run --systemd=false. Note that the systemd behavior
#   only happens when Podman sees the command to be executed is systemd or
#   init.

# leave commented and unset
#ENTRYPOINT ["DO-NOT-USE"]

# do not change
CMD [ "/sbin/init" ]

#
# PUBLISHED SERVICES
#

EXPOSE 9869/tcp
EXPOSE 2633/tcp
EXPOSE 2474/tcp
EXPOSE 5030/tcp
EXPOSE 29876/tcp

