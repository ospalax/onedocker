#
# ONE Docker
#

ARG DEBIAN_VERSION=10
FROM debian:${DEBIAN_VERSION}
LABEL version="1.0" \
    maintainer="Petr OspalÃ½ (pospaly@opennebula.io)" \
    description="ONE Docker - Dockerized OpenNebula"

#
# BUILD ARGS
#

ARG DEBIAN_VERSION
ARG OPENNEBULA_VERSION=5.12
# TODO: ARG DOCKER_VERSION=19.03

#
# PACKAGES
#

# basic packages
RUN DEBIAN_FRONTEND=noninteractive && export DEBIAN_FRONTEND \
    && apt-get update && apt-get upgrade -y \
    && apt-get install -y --no-install-recommends \
        apt-transport-https \
        apt-utils \
        ca-certificates \
        curl \
        gnupg2 \
        openssl \
        systemd \
        systemd-sysv \
    && apt-get clean && rm -rf /tmp/* /var/tmp/*

# prepare opennebula repo
RUN curl -fsSL -o - https://downloads.opennebula.io/repo/repo.key | apt-key add -
RUN echo "deb https://downloads.opennebula.io/repo/${OPENNEBULA_VERSION}/Debian/10 stable opennebula" \
    > /etc/apt/sources.list.d/opennebula.list

# prepare docker repo
RUN curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add -
RUN . /etc/os-release && echo \
        "deb [arch=amd64] https://download.docker.com/linux/debian ${VERSION_CODENAME} stable" \
    > /etc/apt/sources.list.d/docker.list

# opennebula packages and dependencies
RUN DEBIAN_FRONTEND=noninteractive && export DEBIAN_FRONTEND \
    && apt-get update && apt-get install -y --no-install-recommends \
        mariadb-client \
        docker-ce-cli \
        opennebula \
        opennebula-flow \
        opennebula-gate \
        opennebula-sunstone \
        procps \
        sudo \
        file \
        uuid-runtime \
    && apt-get clean && rm -rf /tmp/* /var/tmp/*

# ruby dependencies - deprecated since 5.10
#RUN gem install bundler --version '< 2'
#RUN apt-get update && \
#    DEBIAN_FRONTEND=noninteractive /usr/share/one/install_gems --yes \
#    && apt-get clean && rm -rf /tmp/* /var/tmp/*

#
# CONFIGURATION
#

# each container should have unique machine-id (autogenerated on start)
RUN rm -f /etc/machine-id

# we cannot use the entrypoint (explanation below) so we will have to configure
# the onedocker deployment via systemd's oneshot service

# onedocker script which is doing the heavy-lifting
COPY onedocker-frontend.sh /
RUN chown root:root /onedocker-frontend.sh
RUN chmod 755 /onedocker-frontend.sh

# oneshot systemd service to execute onedocker script
COPY onedocker-frontend.service /etc/systemd/system/
RUN chown root:root /etc/systemd/system/onedocker-frontend.service
RUN chmod 644 /etc/systemd/system/onedocker-frontend.service

# disable autostart of opennebula services
RUN systemctl list-unit-files | \
    awk '{if (($1 ~ /^opennebula/) && ($2 != "static")) print $1;}' | \
    while read -r _oneservice ; do \
        systemctl mask "${_oneservice}" ; \
    done ;

# disable other unwanted systemd stuff
RUN systemctl mask sshd.service \
    && systemctl mask apt-daily.timer \
    && systemctl mask apt-daily-upgrade.timer \
    ;

# setup our entrypoint replacement - oneshot service
RUN systemctl enable onedocker-frontend.service

# cleanup the oneadmin's ssh
RUN for f in authorized_keys id_rsa id_rsa.pub ; do rm -f "/var/lib/one/.ssh/${f}" ; done

#
# ENTRYPOINT
#

# systemd workarounds

# this hints the systemd that it is running inside a container
#ENV container docker

# Source: https://developers.redhat.com/blog/2016/09/13/running-systemd-in-a-non-privileged-container/
#
#   Systemd does not exit on sigterm. Systemd defines that shutdown signal as
#   SIGRTMIN+3, docker upstream should send this signal when user does a docker
#   stop.
STOPSIGNAL SIGRTMIN+3

# BEWARE: this command directive and *EMPTY* entrypoint is mandatory for podman
# to do some hidden hacks allowing systemd to mount cgroup and be able to run
# inside the container...
#
# Source: https://developers.redhat.com/blog/2019/04/24/how-to-run-systemd-in-a-container/
#
#   When Podman starts a container that is running init or systemd as its
#   initial command, Podman automatically sets up the tmpfs and Cgroups for
#   systemd to start without a problem. If you want to block the systemd
#   behavior, you have to run --systemd=false. Note that the systemd behavior
#   only happens when Podman sees the command to be executed is systemd or
#   init.

# leave commented and unset
#ENTRYPOINT ["DO-NOT-USE"]

# do not change
CMD [ "/sbin/init" ]

#
# PUBLISHED SERVICES
#

EXPOSE 9869/tcp
EXPOSE 2633/tcp
EXPOSE 2474/tcp
EXPOSE 5030/tcp

